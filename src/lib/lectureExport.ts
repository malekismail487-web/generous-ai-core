// Lecture export utilities: PDF, DOCX, PPTX
import jsPDF from 'jspdf';

function stripMarkdown(text: string): string {
  return text
    .replace(/#{1,6}\s+/g, '')
    .replace(/\*\*(.*?)\*\*/g, '$1')
    .replace(/\*(.*?)\*/g, '$1')
    .replace(/`{1,3}(.*?)`{1,3}/gs, '$1')
    .replace(/\[(.*?)\]\(.*?\)/g, '$1')
    .replace(/^[-*+]\s+/gm, '• ')
    .replace(/^\d+\.\s+/gm, '')
    .replace(/\\\((.*?)\\\)/gs, '$1')
    .replace(/\$\$(.*?)\$\$/gs, '$1')
    .replace(/\$(.*?)\$/g, '$1')
    .trim();
}

export async function exportAsPDF(title: string, content: string): Promise<void> {
  const pdf = new jsPDF({ unit: 'mm', format: 'a4' });
  const pageWidth = pdf.internal.pageSize.getWidth();
  const margin = 20;
  const maxWidth = pageWidth - margin * 2;
  let y = margin;

  // Title
  pdf.setFontSize(18);
  pdf.setFont('helvetica', 'bold');
  const titleLines = pdf.splitTextToSize(title, maxWidth);
  pdf.text(titleLines, margin, y);
  y += titleLines.length * 8 + 6;

  // Divider
  pdf.setDrawColor(100, 100, 255);
  pdf.line(margin, y, pageWidth - margin, y);
  y += 8;

  // Content
  pdf.setFontSize(11);
  pdf.setFont('helvetica', 'normal');
  const clean = stripMarkdown(content);
  const paragraphs = clean.split('\n').filter(Boolean);

  for (const para of paragraphs) {
    const lines = pdf.splitTextToSize(para, maxWidth);
    if (y + lines.length * 6 > pdf.internal.pageSize.getHeight() - margin) {
      pdf.addPage();
      y = margin;
    }
    pdf.text(lines, margin, y);
    y += lines.length * 6 + 3;
  }

  pdf.save(`${title.replace(/[^a-z0-9]/gi, '_')}.pdf`);
}

export async function exportAsDOCX(title: string, content: string): Promise<void> {
  // Use docx library dynamically
  const { Document, Packer, Paragraph, TextRun, HeadingLevel } = await import('docx');

  const clean = stripMarkdown(content);
  const lines = clean.split('\n').filter(Boolean);

  const children = [
    new Paragraph({
      text: title,
      heading: HeadingLevel.HEADING_1,
    }),
    ...lines.map(line =>
      new Paragraph({
        children: [new TextRun({ text: line, size: 24 })],
        spacing: { after: 100 },
      })
    ),
  ];

  const doc = new Document({
    sections: [{ properties: {}, children }],
  });

  const blob = await Packer.toBlob(doc);
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${title.replace(/[^a-z0-9]/gi, '_')}.docx`;
  a.click();
  URL.revokeObjectURL(url);
}

export async function exportAsPPTX(title: string, content: string): Promise<void> {
  const pptxgenjs = await import('pptxgenjs');
  const PptxGenJS = pptxgenjs.default;
  const pptx = new PptxGenJS();

  pptx.layout = 'LAYOUT_WIDE';
  pptx.theme = { headFontFace: 'Arial', bodyFontFace: 'Arial' };

  const clean = stripMarkdown(content);
  const paragraphs = clean.split('\n\n').filter(Boolean);

  // Title slide
  const titleSlide = pptx.addSlide();
  titleSlide.background = { color: '6366F1' };
  titleSlide.addText(title, {
    x: 0.5, y: 1.5, w: '90%', h: 2,
    fontSize: 36, bold: true, color: 'FFFFFF', align: 'center',
  });
  titleSlide.addText('Generated by Study Bright AI', {
    x: 0.5, y: 3.8, w: '90%', h: 0.5,
    fontSize: 14, color: 'E0E7FF', align: 'center',
  });

  // Content slides — ~2 paragraphs per slide
  const chunkSize = 2;
  for (let i = 0; i < paragraphs.length; i += chunkSize) {
    const slide = pptx.addSlide();
    const chunk = paragraphs.slice(i, i + chunkSize).join('\n\n');
    const slideNum = Math.floor(i / chunkSize) + 1;

    slide.addText(`Part ${slideNum}`, {
      x: 0.5, y: 0.3, w: '90%', h: 0.6,
      fontSize: 18, bold: true, color: '6366F1',
    });
    slide.addText(chunk, {
      x: 0.5, y: 1.1, w: '90%', h: 5.5,
      fontSize: 14, color: '1F2937', align: 'left',
      valign: 'top', wrap: true,
    });
  }

  await pptx.writeFile({ fileName: `${title.replace(/[^a-z0-9]/gi, '_')}.pptx` });
}
